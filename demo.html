<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Realistic Blackjack Table</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{ 
      --bg:#1a1a1a; 
      --table:#0d4f2a; 
      --table-dark:#0a3d20; 
      --card:#ffffff; 
      --muted:#7c8690; 
      --accent:#fbc02d; 
      --chip:#debe87;
      --seat-empty:#2a5f3a;
      --seat-player:#4a8f5a;
      --seat-ai:#3a7f4a;
      --seat-active:#6faf7f;
    }
    
    body { 
      font-family: Inter, Roboto, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      margin: 0; background: var(--bg); color: #fff; overflow: hidden;
    }
    
    .game-container {
      width: 100vw; height: 100vh; display: flex; flex-direction: column;
    }
    
    .header {
      background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
      padding: 12px 24px; display: flex; justify-content: space-between; align-items: center;
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
    }
    
    .header h1 { margin: 0; font-weight: 600; font-size: 20px; }
    .chips-display { background: var(--chip); color: #000; padding: 8px 16px; border-radius: 20px; font-weight: 700; }
    
    .table-container {
      flex: 1; display: flex; justify-content: center; align-items: center; position: relative;
    }
    
    .blackjack-table {
      width: 900px; height: 500px; background: radial-gradient(ellipse at center, var(--table) 0%, var(--table-dark) 100%);
      border-radius: 200px; position: relative; box-shadow: 
        0 0 60px rgba(0,0,0,0.5),
        inset 0 0 40px rgba(0,0,0,0.3);
    }
    
    .dealer-area {
      position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
      display: flex; flex-direction: column; align-items: center;
    }
    
    .dealer-chips {
      background: var(--chip); color: #000; padding: 4px 12px; border-radius: 16px;
      font-weight: 600; font-size: 14px; margin-bottom: 8px;
    }
    
    .dealer-cards {
      display: flex; gap: 4px; min-height: 120px;
    }
    
    .seats-container {
      position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
      width: 900px; display: flex; justify-content: space-between;
    }
    
    .seat {
      width: 160px; height: 180px; background: var(--seat-empty); border-radius: 80px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      position: relative; transition: all 300ms ease; cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .seat.player-owned { background: var(--seat-player); }
    .seat.ai-owned { background: var(--seat-ai); }
    .seat.active { 
      background: var(--seat-active); 
      box-shadow: 0 0 20px rgba(111, 255, 127, 0.4);
      transform: scale(1.05);
    }
    
    .seat:hover { transform: scale(1.02); }
    
    .seat-number {
      position: absolute; top: 8px; left: 8px; background: rgba(0,0,0,0.5);
      width: 24px; height: 24px; border-radius: 12px; display: flex; align-items: center;
      justify-content: center; font-size: 12px; font-weight: 600;
    }
    
    .player-name {
      font-weight: 600; font-size: 14px; margin-bottom: 4px;
    }
    
    .seat-cards {
      display: flex; gap: 2px; min-height: 80px; align-items: center;
    }
    
    .seat-bet {
      position: absolute; bottom: 8px; background: var(--chip); color: #000;
      padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 600;
    }
    
    .card {
      width: 70px; height: 98px; background: white; border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center;
      justify-content: center; font-weight: 700; position: relative; color: #111;
      transition: all 200ms ease;
    }
    
    .card:hover { transform: translateY(-4px); box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
    
    .card.dealing {
      animation: cardDeal 400ms ease-out;
    }
    
    @keyframes cardDeal {
      from { transform: scale(0.8) rotate(10deg); opacity: 0; }
      to { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    
    .card.flipping {
      animation: cardFlip 600ms ease-in-out;
    }
    
    @keyframes cardFlip {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(0deg); }
    }
    
    .action-panel {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 12px; padding: 16px; background: rgba(0,0,0,0.8);
      border-radius: 16px; backdrop-filter: blur(10px);
    }
    
    .btn {
      background: var(--accent); border: none; padding: 12px 20px; border-radius: 10px;
      font-weight: 600; cursor: pointer; transition: all 150ms ease;
      min-width: 80px;
    }
    
    .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(251, 192, 45, 0.3); }
    .btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
    .btn.secondary { background: rgba(255,255,255,0.1); color: #fff; }
    .btn.secondary:hover { background: rgba(255,255,255,0.2); }
    
    .bet-controls {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 12px; align-items: center; padding: 12px 20px;
      background: rgba(0,0,0,0.8); border-radius: 12px; backdrop-filter: blur(10px);
    }
    
    .bet-input {
      width: 80px; padding: 8px; border-radius: 6px; border: none;
      background: rgba(255,255,255,0.1); color: #fff; font-weight: 600;
      text-align: center;
    }
    
    .countdown {
      position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
      background: rgba(251, 192, 45, 0.9); color: #000; padding: 8px 16px;
      border-radius: 20px; font-weight: 700; font-size: 18px;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }
    
    .hand-value {
      position: absolute; top: -25px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); color: #fff; padding: 4px 8px;
      border-radius: 12px; font-size: 14px; font-weight: 600;
      min-width: 40px; text-align: center;
    }
    
    .hand-value.soft { color: var(--accent); }
    .hand-value.blackjack { background: var(--accent); color: #000; }
    
    .result-label {
      position: absolute; top: -50px; left: 50%; transform: translateX(-50%);
      padding: 6px 12px; border-radius: 16px; font-weight: 700; font-size: 16px;
      animation: resultPop 400ms ease-out;
    }
    
    @keyframes resultPop {
      from { transform: translateX(-50%) scale(0); opacity: 0; }
      to { transform: translateX(-50%) scale(1); opacity: 1; }
    }
    
    .result-label.win { background: #4caf50; color: #fff; }
    .result-label.lose { background: #f44336; color: #fff; }
    .result-label.push { background: #ff9800; color: #fff; }
    .result-label.blackjack { background: var(--accent); color: #000; }
    
    .chip-animation {
      position: absolute; width: 30px; height: 30px; background: var(--chip);
      border-radius: 15px; display: flex; align-items: center; justify-content: center;
      font-size: 12px; font-weight: 700; color: #000; pointer-events: none;
      animation: chipFly 600ms ease-out;
    }
    
    @keyframes chipFly {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    
    .ai-join-animation {
      animation: aiJoin 800ms ease-out;
    }
    
    @keyframes aiJoin {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    
    .ai-leave-animation {
      animation: aiLeave 600ms ease-out;
    }
    
    @keyframes aiLeave {
      from { transform: scale(1); opacity: 1; }
      to { transform: scale(0.8); opacity: 0; }
    }

    /* Main Menu Styles */
    .main-menu {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      display: flex; align-items: center; justify-content: center;
      z-index: 1000;
    }

    .menu-content {
      text-align: center; max-width: 400px; padding: 40px;
      background: rgba(0,0,0,0.6); border-radius: 20px;
      backdrop-filter: blur(10px); box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .menu-content h1 {
      font-size: 36px; margin-bottom: 16px; color: var(--accent);
      text-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .menu-content p {
      font-size: 18px; margin-bottom: 32px; color: #ccc;
      line-height: 1.5;
    }

    .btn.primary {
      background: var(--accent); color: #000; padding: 16px 32px;
      font-size: 18px; font-weight: 700; border: none;
      border-radius: 12px; cursor: pointer; transition: all 200ms ease;
      min-width: 160px;
    }

    .btn.primary:hover {
      transform: translateY(-2px); box-shadow: 0 6px 20px rgba(251, 192, 45, 0.4);
    }

    .btn.primary:active { transform: translateY(0); }
  </style>
</head>
<body>
  <!-- Main Menu -->
  <div class="main-menu" id="mainMenu">
    <div class="menu-content">
      <h1>Realistic Blackjack</h1>
      <p>Take a seat at the table and test your luck!</p>
      <button class="btn primary" id="startGameBtn">Start Game</button>
    </div>
  </div>

  <!-- Game Container -->
  <div class="game-container" id="gameContainer" style="display: none;">
    <div class="header">
      <h1>Realistic Blackjack</h1>
      <div class="chips-display" id="chips">Chips: 1000</div>
      <button class="btn secondary" id="leaveGameBtn" style="display: none;">Leave Table</button>
    </div>
    
    <div class="table-container">
      <div class="blackjack-table">
        <div class="dealer-area">
          <div class="dealer-chips">Dealer</div>
          <div class="dealer-cards" id="dealerCards"></div>
          <div class="hand-value" id="dealerValue" style="display: none;"></div>
        </div>
        
        <div class="seats-container" id="seatsContainer">
          <!-- Seats will be generated by JavaScript -->
        </div>
      </div>
      
      <div class="bet-controls" id="betControls">
        <input class="bet-input" id="betInput" value="10" />
        <button class="btn" id="placeBetBtn">Place Bet</button>
        <button class="btn secondary" id="startRoundBtn">Start Round</button>
      </div>
      
      <div class="action-panel" id="actionPanel" style="display: none;">
        <button class="btn" id="hitBtn">Hit</button>
        <button class="btn" id="standBtn">Stand</button>
        <button class="btn" id="doubleBtn">Double</button>
        <button class="btn secondary" id="surrenderBtn">Surrender</button>
      </div>
      
      <div class="countdown" id="countdown" style="display: none;"></div>
    </div>
  </div>

  <script>
    (function(){
      const MAX_SEATS = 3
      const MAX_AI = 2
      const BETTING_SECONDS = 12
      const DEAL_DELAY_MS = 180
      const AI_THINK_MS = 320

      const els = {
        mainMenu: document.getElementById('mainMenu'),
        gameContainer: document.getElementById('gameContainer'),
        startGameBtn: document.getElementById('startGameBtn'),
        leaveGameBtn: document.getElementById('leaveGameBtn'),
        chips: document.getElementById('chips'),
        dealerCards: document.getElementById('dealerCards'),
        dealerValue: document.getElementById('dealerValue'),
        seatsContainer: document.getElementById('seatsContainer'),
        betControls: document.getElementById('betControls'),
        betInput: document.getElementById('betInput'),
        placeBetBtn: document.getElementById('placeBetBtn'),
        startRoundBtn: document.getElementById('startRoundBtn'),
        actionPanel: document.getElementById('actionPanel'),
        hitBtn: document.getElementById('hitBtn'),
        standBtn: document.getElementById('standBtn'),
        doubleBtn: document.getElementById('doubleBtn'),
        surrenderBtn: document.getElementById('surrenderBtn'),
        countdown: document.getElementById('countdown')
      }

      const aiNamePool = [
        { name: 'Dave', tag: 'casual' },
        { name: 'Sarah', tag: 'serious' },
        { name: 'Mike', tag: 'reckless' },
        { name: 'Lisa', tag: 'lucky' },
        { name: 'Tom', tag: 'casual' },
        { name: 'Nina', tag: 'serious' },
        { name: 'Raj', tag: 'lucky' },
        { name: 'Ben', tag: 'reckless' },
        { name: 'Emma', tag: 'casual' }
      ]

      function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min }
      function pick(arr){ return arr[Math.floor(Math.random() * arr.length)] }
      function sleep(ms){ return new Promise(r => setTimeout(r, ms)) }

      const state = {
        chips: 1000,
        phase: 'idle', // 'idle' | 'betting' | 'dealing' | 'playing' | 'dealer' | 'resolution'
        deck: [],
        dealer: { cards: [], revealed: false },
        seats: [],
        activeSeatId: 0,
        turnSeatId: null,
        bettingEndsAt: 0,
        timer: null
      }

      function createAiProfile(){
        const identity = pick(aiNamePool)
        const risk = pick(['conservative','standard','aggressive'])
        const bankrollTier = pick(['low','mid','high'])
        const bankroll = bankrollTier === 'low' ? rand(80,180) : bankrollTier === 'mid' ? rand(200,450) : rand(500,1000)
        const patience = pick(['short','medium','long'])
        const patienceHands = patience === 'short' ? rand(3,7) : patience === 'medium' ? rand(6,14) : rand(12,25)
        const leaveOnWin = rand(120, 260)
        const leaveOnLoss = -rand(120, 260)
        return {
          name: identity.name,
          tag: identity.tag,
          risk,
          bankroll,
          startBankroll: bankroll,
          patienceHands,
          handsPlayed: 0,
          leaveOnWin,
          leaveOnLoss
        }
      }

      function newSeat(id){
        return {
          id,
          occupied: false,
          isPlayer: false,
          ai: null,
          cards: [],
          bet: 0,
          result: null,
          surrendered: false,
          doubled: false,
          element: null
        }
      }

      function buildDeck(){
        const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K']
        const suits = ['♠','♥','♦','♣']
        const d = []
        for (const r of ranks) for (const s of suits) d.push({ r, s })
        shuffle(d)
        return d
      }

      function shuffle(a){
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1))
          ;[a[i], a[j]] = [a[j], a[i]]
        }
      }

      function handTotal(cards){
        let total = 0
        let aces = 0
        for (const c of cards) {
          if (c.r === 'A') { total += 11; aces++ }
          else if (c.r === 'J' || c.r === 'Q' || c.r === 'K') total += 10
          else total += parseInt(c.r, 10)
        }
        while (total > 21 && aces > 0) { total -= 10; aces-- }
        return total
      }

      function isSoft(cards){
        let total = 0
        let aces = 0
        for (const c of cards) {
          if (c.r === 'A') { total += 11; aces++ }
          else if (c.r === 'J' || c.r === 'Q' || c.r === 'K') total += 10
          else total += parseInt(c.r, 10)
        }
        // if we have at least one ace counted as 11 after reductions, it's soft
        while (total > 21 && aces > 0) { total -= 10; aces-- }
        return cards.some(c => c.r === 'A') && total <= 21 && (total - 10) >= 0 && handTotal(cards) !== (handTotal(cards) - 10)
      }

      function suitName(s){
        return s === '♠' ? 'spades' : s === '♥' ? 'hearts' : s === '♦' ? 'diamonds' : s === '♣' ? 'clubs' : 'unknown'
      }

      function cardImgSrc(card){
        const s = suitName(card.s)
        return `demo/cards_custom/card_${card.r}_${s}.svg`
      }

      function cardBackSrc(){
        return 'demo/cards_custom/card_back.svg'
      }

      function clearChildren(el){ while (el.firstChild) el.removeChild(el.firstChild) }

      function makeCardEl(card, faceDown=false, animate=false){
        const wrap = document.createElement('div')
        wrap.className = 'card' + (animate ? ' dealing' : '')
        const img = document.createElement('img')
        img.alt = faceDown ? 'back' : `${card.r}${card.s}`
        img.style.width = '100%'
        img.style.height = '100%'
        img.style.borderRadius = '6px'
        img.src = faceDown ? cardBackSrc() : cardImgSrc(card)
        img.onerror = () => {
          img.onerror = null
          img.src = faceDown ? 'demo/cards/card_back.svg' : `demo/cards/card_${card.r}_${suitName(card.s)}.svg`
        }
        wrap.appendChild(img)
        return wrap
      }

      function render(){
        els.chips.textContent = `Chips: ${state.chips}`
        renderDealer()
        renderSeats()
        renderControls()
      }

      function renderDealer(){
        clearChildren(els.dealerCards)
        const showValue = state.phase === 'dealer' || state.phase === 'resolution' || state.dealer.revealed
        state.dealer.cards.forEach((c, idx) => {
          const isHole = idx === 1
          const faceDown = isHole && !state.dealer.revealed
          els.dealerCards.appendChild(makeCardEl(c, faceDown, false))
        })
        if (showValue) {
          const v = handTotal(state.dealer.cards)
          els.dealerValue.style.display = 'block'
          els.dealerValue.textContent = `${v}`
        } else {
          // Show only the first card's value during dealing
          const firstCard = state.dealer.cards[0]
          if (firstCard) {
            els.dealerValue.style.display = 'block'
            els.dealerValue.textContent = `${firstCard.r === 'A' ? 11 : (firstCard.r === 'J' || firstCard.r === 'Q' || firstCard.r === 'K' ? 10 : parseInt(firstCard.r, 10))}`
          } else {
            els.dealerValue.style.display = 'none'
          }
        }
      }

      function renderSeats(){
        for (const seat of state.seats) {
          const el = seat.element
          el.classList.toggle('player-owned', seat.isPlayer)
          el.classList.toggle('ai-owned', !!seat.ai)
          el.classList.toggle('active', seat.id === state.turnSeatId)
          const nameEl = el.querySelector('.player-name')
          const cardsEl = el.querySelector('.seat-cards')
          const valueEl = el.querySelector('.hand-value')
          const betEl = el.querySelector('.seat-bet')
          clearChildren(cardsEl)

          if (!seat.occupied && !seat.isPlayer && !seat.ai) {
            nameEl.textContent = ''
            valueEl.style.display = 'none'
            betEl.style.display = 'none'
            continue
          }

          nameEl.textContent = seat.isPlayer ? 'You' : (seat.ai ? seat.ai.name : '')
          if (seat.cards.length) {
            for (const c of seat.cards) cardsEl.appendChild(makeCardEl(c, false, false))
            const v = handTotal(seat.cards)
            valueEl.style.display = 'block'
            valueEl.textContent = v <= 21 ? `${v}` : 'BUST'
            valueEl.classList.toggle('blackjack', seat.cards.length === 2 && v === 21)
          } else {
            valueEl.style.display = 'none'
          }

          if (seat.bet > 0) {
            betEl.style.display = 'block'
            betEl.textContent = `$${seat.bet}`
          } else {
            betEl.style.display = 'none'
          }

          // result label
          const existing = el.querySelector('.result-label')
          if (existing) existing.remove()
          if (seat.result) {
            const r = document.createElement('div')
            r.className = `result-label ${seat.result.toLowerCase()}`
            r.textContent = seat.result
            el.appendChild(r)
          }
        }
      }

      function renderControls(){
        const inBetting = state.phase === 'betting' || state.phase === 'idle'
        els.betControls.style.display = inBetting ? 'flex' : 'none'
        els.actionPanel.style.display = (state.phase === 'playing' && state.turnSeatId != null && state.seats[state.turnSeatId].isPlayer) ? 'flex' : 'none'

        // Show leave button only between rounds and when player has at least one seat
        const hasPlayerSeat = state.seats.some(s => s.isPlayer)
        const canLeave = (state.phase === 'idle' || state.phase === 'resolution') && hasPlayerSeat
        els.leaveGameBtn.style.display = canLeave ? 'block' : 'none'

        // action validity
        if (els.actionPanel.style.display !== 'none') {
          const seat = state.seats[state.turnSeatId]
          const total = handTotal(seat.cards)
          const canAct = total > 0 && total < 21 && !seat.result
          els.hitBtn.disabled = !canAct
          els.standBtn.disabled = !canAct
          els.surrenderBtn.disabled = !(canAct && seat.cards.length === 2)
          els.doubleBtn.disabled = !(canAct && seat.cards.length === 2 && state.chips >= seat.bet)
        }
      }

      function showMainMenu(){
        console.log('Showing main menu')
        if (!els.mainMenu || !els.gameContainer) {
          console.error('Elements not found:', { mainMenu: els.mainMenu, gameContainer: els.gameContainer })
          return
        }
        els.mainMenu.style.display = 'flex'
        els.gameContainer.style.display = 'none'
        // Reset game state
        state.phase = 'idle'
        state.chips = 1000
        state.seats = []
        state.activeSeatId = 0
        state.turnSeatId = null
        if (state.timer) { clearInterval(state.timer); state.timer = null }
      }

      function startGame(){
        console.log('Start game clicked')
        if (!els.mainMenu || !els.gameContainer) {
          console.error('Elements not found in startGame:', { mainMenu: els.mainMenu, gameContainer: els.gameContainer })
          return
        }
        els.mainMenu.style.display = 'none'
        els.gameContainer.style.display = 'flex'
        init()
      }

      function leaveGame(){
        if (state.phase !== 'idle' && state.phase !== 'resolution') return
        showMainMenu()
      }

      function setCountdown(seconds){
        state.bettingEndsAt = Date.now() + seconds * 1000
        els.countdown.style.display = 'block'
        tickCountdown()
        if (state.timer) clearInterval(state.timer)
        state.timer = setInterval(tickCountdown, 200)
      }

      function tickCountdown(){
        const remainingMs = state.bettingEndsAt - Date.now()
        const s = Math.max(0, Math.ceil(remainingMs / 1000))
        if (state.phase !== 'betting') {
          els.countdown.style.display = 'none'
          if (state.timer) { clearInterval(state.timer); state.timer = null }
          return
        }
        els.countdown.textContent = `BETTING: ${s}`
        if (remainingMs <= 0) {
          if (state.timer) { clearInterval(state.timer); state.timer = null }
          els.countdown.style.display = 'none'
          startDealingIfReady()
        }
      }

      function toggleSeatSelection(id){
        if (state.phase !== 'idle' && state.phase !== 'betting') return
        const seat = state.seats[id]
        // Don't let player remove the last player seat
        const playerCount = state.seats.filter(s => s.isPlayer).length
        if (seat.isPlayer && playerCount <= 1) return

        if (seat.ai) {
          // can't select AI seat
          return
        }
        seat.isPlayer = !seat.isPlayer
        seat.occupied = seat.isPlayer
        if (!seat.isPlayer) {
          seat.bet = 0
          seat.cards = []
          seat.result = null
        }
        state.activeSeatId = id
        render()
      }

      function setActiveBetSeat(id){
        if (state.phase !== 'idle' && state.phase !== 'betting') return
        const seat = state.seats[id]
        if (!seat.isPlayer) return
        state.activeSeatId = id
        render()
      }

      function createSeatElements(){
        state.seats = []
        els.seatsContainer.innerHTML = ''
        for (let i = 0; i < MAX_SEATS; i++) {
          const seat = newSeat(i)
          const seatEl = document.createElement('div')
          seatEl.className = 'seat'
          seatEl.id = `seat-${i}`
          seatEl.innerHTML = `
            <div class="seat-number">${i + 1}</div>
            <div class="player-name"></div>
            <div class="seat-cards"></div>
            <div class="hand-value" style="display: none;"></div>
            <div class="seat-bet" style="display: none;"></div>
          `
          seatEl.addEventListener('click', () => {
            // click chooses bet seat if already player, else toggles player selection
            if (seat.isPlayer) setActiveBetSeat(i)
            else toggleSeatSelection(i)
          })
          els.seatsContainer.appendChild(seatEl)
          seat.element = seatEl
          state.seats.push(seat)
        }
        // default player seat (middle seat)
        state.seats[1].isPlayer = true
        state.seats[1].occupied = true
        state.activeSeatId = 1
      }

      function aiCount(){ return state.seats.filter(s => !!s.ai).length }

      function maybeAiJoinBetweenHands(){
        if (aiCount() >= MAX_AI) return
        // chance to join
        if (Math.random() > 0.55) return
        const empty = state.seats.filter(s => !s.isPlayer && !s.ai)
        if (!empty.length) return
        const seat = pick(empty)
        seat.ai = createAiProfile()
        seat.occupied = true
        seat.element.classList.add('ai-join-animation')
        setTimeout(() => seat.element.classList.remove('ai-join-animation'), 850)
      }

      function maybeAiLeaveBetweenHands(){
        for (const seat of state.seats) {
          if (!seat.ai) continue
          const ai = seat.ai
          ai.handsPlayed += 1
          const delta = ai.bankroll - ai.startBankroll
          const outOfMoney = ai.bankroll <= 0
          const patienceExpired = ai.handsPlayed >= ai.patienceHands
          const hitWin = delta >= ai.leaveOnWin
          const hitLoss = delta <= ai.leaveOnLoss
          const casual = Math.random() < 0.06
          if (outOfMoney || patienceExpired || hitWin || hitLoss || casual) {
            seat.element.classList.add('ai-leave-animation')
            setTimeout(() => {
              seat.element.classList.remove('ai-leave-animation')
              seat.ai = null
              seat.occupied = false
              seat.bet = 0
              seat.cards = []
              seat.result = null
              render()
            }, 600)
          }
        }
      }

      function startBettingPhase(){
        if (state.phase !== 'idle' && state.phase !== 'resolution') return
        state.phase = 'betting'
        // clear hands but preserve bet amounts for player seats
        state.dealer = { cards: [], revealed: false }
        for (const seat of state.seats) {
          seat.cards = []
          seat.result = null
          seat.surrendered = false
          seat.doubled = false
          if (!seat.isPlayer && !seat.ai) {
            seat.bet = 0
            seat.occupied = false
          }
          if (seat.ai) {
            seat.bet = 0
          }
        }
        setCountdown(20) // 20-second betting timer
        render()
      }

      function placeBet(){
        if (state.phase !== 'betting' && state.phase !== 'idle') return
        const amt = parseInt(els.betInput.value, 10) || 0
        if (amt <= 0) return
        const seat = state.seats[state.activeSeatId]
        if (!seat || !seat.isPlayer) return
        // Only check if we have enough chips to set this bet amount
        if (amt > state.chips + seat.bet) return
        seat.bet = amt
        seat.occupied = true
        render()
      }

      function autoAiBets(){
        for (const seat of state.seats) {
          if (!seat.ai) continue
          const ai = seat.ai
          // base sizing
          const base = ai.risk === 'conservative' ? rand(5,15) : ai.risk === 'standard' ? rand(10,30) : rand(20,60)
          const cap = Math.max(5, Math.floor(ai.bankroll * 0.25))
          const bet = Math.min(base, cap)
          seat.bet = bet
          seat.occupied = bet > 0
        }
      }

      function ensureAiFillAtRoundStart(){
        // At round start, optionally fill some empty seats with AI (doesn't block player)
        const empty = state.seats.filter(s => !s.isPlayer && !s.ai)
        for (const seat of empty) {
          if (aiCount() >= MAX_AI) break
          if (Math.random() < 0.45) {
            seat.ai = createAiProfile()
            seat.occupied = true
            seat.element.classList.add('ai-join-animation')
            setTimeout(() => seat.element.classList.remove('ai-join-animation'), 850)
          }
        }
      }

      function deductPlayerBets(){
        // Deduct bets from player balance for all player seats
        for (const seat of state.seats) {
          if (seat.isPlayer && seat.bet > 0) {
            if (state.chips >= seat.bet) {
              state.chips -= seat.bet
            } else {
              // Not enough chips, clear bet and disable seat
              seat.bet = 0
              seat.occupied = false
            }
          }
        }
      }

      async function startDealingIfReady(){
        if (state.phase !== 'betting') return
        // Check if any bets were placed (player or AI)
        const anyBet = state.seats.some(s => s.occupied && s.bet > 0)
        if (!anyBet) {
          // No bets at all, restart betting phase
          startBettingPhase()
          return
        }
        
        // Deduct actual chips from player balance now
        deductPlayerBets()
        ensureAiFillAtRoundStart()
        autoAiBets()
        
        // Check again if AI placed bets after autoAiBets
        const aiBets = state.seats.some(s => s.ai && s.bet > 0)
        const playerBets = state.seats.some(s => s.isPlayer && s.bet > 0)
        
        if (!aiBets && !playerBets) {
          // Still no bets, restart betting
          startBettingPhase()
          return
        }
        
        state.deck = buildDeck()
        state.dealer = { cards: [], revealed: false }
        state.phase = 'dealing'
        render()
        await initialDeal()
        await startTurnLoop()
      }

      async function dealCardToSeat(seat, animate=true){
        const c = state.deck.pop()
        seat.cards.push(c)
        render()
        if (animate) await sleep(DEAL_DELAY_MS)
      }

      async function dealCardToDealer(){
        const c = state.deck.pop()
        state.dealer.cards.push(c)
        render()
        await sleep(DEAL_DELAY_MS)
      }

      async function initialDeal(){
        // deal clockwise: seats 0..5, then dealer, repeat
        const order = state.seats.filter(s => s.occupied && s.bet > 0).map(s => s.id)
        for (let round = 0; round < 2; round++) {
          for (const id of order) {
            await dealCardToSeat(state.seats[id], true)
          }
          await dealCardToDealer()
        }
        // hole card face-down (render does that)
        state.phase = 'playing'
        render()
      }

      function seatIsDone(seat){
        const t = handTotal(seat.cards)
        return seat.result != null || seat.surrendered || t >= 21
      }

      function canSeatAct(seat){
        const t = handTotal(seat.cards)
        return seat.bet > 0 && seat.occupied && !seat.surrendered && seat.result == null && t > 0 && t < 21
      }

      function markBustIfNeeded(seat){
        const t = handTotal(seat.cards)
        if (t > 21) seat.result = 'LOSE'
      }

      async function startTurnLoop(){
        // player/AI seats in order
        const turnOrder = state.seats.filter(s => s.occupied && s.bet > 0).map(s => s.id)
        for (const id of turnOrder) {
          const seat = state.seats[id]
          state.turnSeatId = id
          render()
          if (seat.ai) {
            await aiPlaySeat(seat)
          } else if (seat.isPlayer) {
            await playerPlaySeat(seat)
          }
          markBustIfNeeded(seat)
          render()
          await sleep(220)
        }
        await dealerTurnAndResolve()
      }

      function waitForPlayerAction(){
        return new Promise(resolve => {
          const seat = state.seats[state.turnSeatId]

          function cleanup(){
            els.hitBtn.onclick = null
            els.standBtn.onclick = null
            els.doubleBtn.onclick = null
            els.surrenderBtn.onclick = null
          }

          els.hitBtn.onclick = async () => {
            if (!canSeatAct(seat)) return
            cleanup()
            await dealCardToSeat(seat)
            markBustIfNeeded(seat)
            resolve('hit')
          }

          els.standBtn.onclick = () => {
            if (!canSeatAct(seat)) return
            cleanup()
            resolve('stand')
          }

          els.doubleBtn.onclick = async () => {
            if (!(seat.cards.length === 2 && state.chips >= seat.bet)) return
            cleanup()
            state.chips -= seat.bet
            seat.bet *= 2
            seat.doubled = true
            await dealCardToSeat(seat)
            markBustIfNeeded(seat)
            resolve('double')
          }

          els.surrenderBtn.onclick = () => {
            if (seat.cards.length !== 2) return
            cleanup()
            seat.surrendered = true
            // return half bet to player
            const refund = Math.floor(seat.bet / 2)
            state.chips += refund
            seat.result = 'LOSE'
            resolve('surrender')
          }

          render()
        })
      }

      async function playerPlaySeat(seat){
        while (canSeatAct(seat)) {
          const total = handTotal(seat.cards)
          if (seat.cards.length === 2 && total === 21) break
          const action = await waitForPlayerAction()
          if (action === 'stand' || action === 'surrender') break
          render()
          await sleep(90)
          if (!canSeatAct(seat)) break
        }
      }

      function aiWantsDouble(ai, seat){
        if (seat.cards.length !== 2) return false
        const t = handTotal(seat.cards)
        if (t < 9 || t > 11) return false
        const p = ai.risk === 'aggressive' ? 0.55 : ai.risk === 'standard' ? 0.25 : 0.12
        return Math.random() < p
      }

      function aiHitThreshold(ai, seat){
        // simple atmospheric logic
        if (ai.risk === 'conservative') return 16
        if (ai.risk === 'standard') return 17
        return 18
      }

      async function aiPlaySeat(seat){
        const ai = seat.ai
        await sleep(AI_THINK_MS)
        if (aiWantsDouble(ai, seat) && ai.bankroll >= seat.bet) {
          ai.bankroll -= seat.bet
          seat.bet *= 2
          seat.doubled = true
          await dealCardToSeat(seat)
          return
        }
        while (canSeatAct(seat)) {
          const t = handTotal(seat.cards)
          if (t >= aiHitThreshold(ai, seat)) break
          await sleep(AI_THINK_MS)
          await dealCardToSeat(seat)
          markBustIfNeeded(seat)
          if (handTotal(seat.cards) >= 21) break
        }
      }

      function dealerShouldHit(){
        const t = handTotal(state.dealer.cards)
        // stand on soft 17
        if (t < 17) return true
        return false
      }

      async function dealerTurnAndResolve(){
        state.phase = 'dealer'
        state.dealer.revealed = true
        render()
        await sleep(420)
        while (dealerShouldHit()) {
          await dealCardToDealer()
          render()
          await sleep(220)
        }
        state.phase = 'resolution'
        resolvePayouts()
        render()
        await sleep(750)
        maybeAiLeaveBetweenHands()
        maybeAiJoinBetweenHands()
        await startResolutionTimer()
      }

      async function startResolutionTimer(){
        state.phase = 'resolution'
        render()
        
        // Show 5-second countdown
        let countdown = 5
        els.countdown.style.display = 'block'
        els.countdown.textContent = `Next round in: ${countdown}`
        
        const resolutionInterval = setInterval(() => {
          countdown--
          if (countdown > 0) {
            els.countdown.textContent = `Next round in: ${countdown}`
          } else {
            clearInterval(resolutionInterval)
            els.countdown.style.display = 'none'
            startBettingPhase()
          }
        }, 1000)
        
        // Allow player to skip the timer
        els.startRoundBtn.style.display = 'block'
        els.startRoundBtn.textContent = 'Skip Wait'
        els.startRoundBtn.onclick = () => {
          clearInterval(resolutionInterval)
          els.countdown.style.display = 'none'
          els.startRoundBtn.style.display = 'none'
          startBettingPhase()
        }
        
        // Auto-hide skip button after timer ends
        setTimeout(() => {
          els.startRoundBtn.style.display = 'none'
        }, 5000)
      }

      function resolvePayouts(){
        const dealerTotal = handTotal(state.dealer.cards)
        const dealerBust = dealerTotal > 21
        for (const seat of state.seats) {
          if (!(seat.occupied && seat.bet > 0)) continue
          const total = handTotal(seat.cards)
          const blackjack = seat.cards.length === 2 && total === 21 && !seat.doubled && !seat.surrendered

          if (seat.surrendered) {
            // already refunded half, remaining half lost
            seat.result = 'LOSE'
          } else if (total > 21) {
            seat.result = 'LOSE'
          } else if (blackjack && !dealerBust && !(state.dealer.cards.length === 2 && dealerTotal === 21)) {
            seat.result = 'BLACKJACK'
            const payout = Math.floor(seat.bet * 2.5)
            if (seat.isPlayer) state.chips += payout
            if (seat.ai) seat.ai.bankroll += payout
          } else if (dealerBust) {
            seat.result = 'WIN'
            const payout = seat.bet * 2
            if (seat.isPlayer) state.chips += payout
            if (seat.ai) seat.ai.bankroll += payout
          } else {
            if (total > dealerTotal) {
              seat.result = 'WIN'
              const payout = seat.bet * 2
              if (seat.isPlayer) state.chips += payout
              if (seat.ai) seat.ai.bankroll += payout
            } else if (total < dealerTotal) {
              seat.result = 'LOSE'
            } else {
              seat.result = 'PUSH'
              const payout = seat.bet
              if (seat.isPlayer) state.chips += payout
              if (seat.ai) seat.ai.bankroll += payout
            }
          }

          // AI loses money when it places bet (we treat bet as taken from bankroll at bet time)
          if (seat.ai) {
            seat.ai.bankroll -= seat.bet
          }
        }
      } // <--- Added closing brace here

      function wireControls(){
        console.log('Setting up controls')
        if (!els.startGameBtn) {
          console.error('startGameBtn not found!')
        } else {
          els.startGameBtn.addEventListener('click', startGame)
          console.log('startGameBtn listener added')
        }
        if (!els.leaveGameBtn) {
          console.error('leaveGameBtn not found!')
        } else {
          els.leaveGameBtn.addEventListener('click', leaveGame)
        }
        if (!els.placeBetBtn) {
          console.error('placeBetBtn not found!')
        } else {
          els.placeBetBtn.addEventListener('click', placeBet)
        }
        if (!els.startRoundBtn) {
          console.error('startRoundBtn not found!')
        } else {
          els.startRoundBtn.addEventListener('click', () => {
            if (state.phase === 'idle' || state.phase === 'resolution') startBettingPhase()
            else if (state.phase === 'betting') startDealingIfReady()
          })
        }
      }

      function init(){
        createSeatElements()
        wireControls()
        state.phase = 'idle'
        render()
      }

      // Initialize everything when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          init()
          showMainMenu()
        })
      } else {
        init()
        showMainMenu()
      }
    })();
  </script>

  <p style="margin-top:18px;color:#666">If you prefer, you can also run a local server: <code>python -m http.server 8081</code> and open <a href="http://localhost:8081/demo.html">http://localhost:8081/demo.html</a></p>
</body>
</html>